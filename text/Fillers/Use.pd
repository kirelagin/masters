Применения заполнителей
------------------------


В терминах заполнителей можно описать многие стандартные операции с путями.
Но сначала обратимся к важному вычислительному свойству заполнителя $1$-короба, которое
позволит в дальнейшем судить о вычислительных свойствах других операций, а именно:
в результате заполнения короба, изображенного на \inlref{рисунке}{img:box-id},
получается вычислительно тот же самый путь:

~~~~
fill-id : {A : Type} {a b : A} (p : a = b)
       -> path (\j ->
            fill-2 (\_ _ -> A) (box-1 a b a b idp idp p) right j)
          = p
fill-id _ _ _ _ = idp
~~~~

Теперь перейдем к простым операциям над путями.

Операция **обращения** пути, доказывающая симметричность
равенства, может быть определена через заполнение короба, изображенного
на \inlref{рисунке}{img:box-inv}, следующим образом: <!-- TODO pic -->

~~~~
inv : {A : Type} {a a' : A} -> a = a' -> a' = a
inv A a a' p = path (\j -> fill-2 (\_ _ -> A)
                                  (box-1 a a a' a p idp idp) right j)
~~~~

При этом, она обладает ожидаемым свойством: путь, обратный к тривиальному,
также тривиален, причем вычислительно (что следует из упомянутого в начале
свойства операции заполнения):

~~~~
idp-inv : {A : Type} {a : A} -> inv (idp' a) = idp' a
idp-inv _ _ = idp
~~~~

**Конкатенацию** путей, являющуюся доказательством транзитивности равенства,
можно определить несколькими способами. Чтобы сделать это, нам потребуется
вспомогательная функция, конкатенирующая _три_ пути. Она всего лишь
берет заполнитель, предварительно обратив один из путей:

~~~~
concat3 : {A : Type} {a b c d : A}
       -> a = b -> b = c -> c = d -> a = d
concat3 A a b c d ab bc cd =
  path (\j -> fill-2 (\_ _ -> A) (box-1 b c a d (inv ab) cd bc) right j)
~~~~

С помощью `concat3` конкатенацию _двух_ путей можно определить тремя
способами — подставив тривиальный путь в качестве первого, второго или третьего.

В первом случае, получим определение, обладающее интересным вычислительным
свойством при конкатенации с тривиальным путем справа:

~~~~
concat-left : {A : Type} {a b c : A} -> a = b -> b = c -> a = c
concat-left _ _ _ _ p q = concat3 idp p q

concat-left-idp : {A : Type} {a b : A} -> (p : a = b)
               -> concat-left p idp = p
concat-left-idp _ _ _ _ = idp
~~~~

В третьем случае — при конкатенации с тривиальным слева:

~~~~
concat-right : {A : Type} {a b c : A} -> a = b -> b = c -> a = c
concat-right _ _ _ _ p q = concat3 p q idp

concat-right-idp : {A : Type} {a b : A} -> (p : a = b)
                -> concat-right idp p = p
concat-right-idp _ _ _ _ = idp
~~~~

Во втором же случае никаких полезных вычислительных свойств не получится,
но зато такое определение более симметрично.

~~~~
concat-mid : {A : Type} {a b c : A} -> a = b -> b = c -> a = c
concat-mid _ _ _ _ p q = concat3 p idp q
~~~~

Это определение эквивалентно определению конкатенации двойной индукцией по путям,
принятому в Книге HoTT[@hottbook]. Два другие же эквивалентны упомянутым
в Книге определениям с помощью индукции только по одному из двух имеющихся путей.


Так определить перечисленные операции можно и в общепринятой («книжной»)
гомотопической теории типов.
Более интересный вариант использования заполнителя специфичен для теории с
интервалом и условиями.

Пусть у нас есть тип `A`, содержащий, помимо прочего, две точки и путь между ними:

~~~~
data A = a | b | ab I | …
  with
    ab left  = a
    ab right = b
    …
~~~~

Пусть также есть некоторый тип `B` и два отображения — `f` и `g` —
типа `A -> B`. Изобразим пути `pmap f ab` и `pmap g ab`
(\inlref{рисунок}{img:filler-hmtp}<!-- TODO pic -->) и заметим, что отображения
гомотопны если, и только если найдутся пути из `f a` в `g a`, из `f b` в `g b`,
а также если можно заполнить получившийся квадрат. Это верно, поскольку
горизонтальные пути, проходящие через квадрат, и есть те самые пути,
которые необходимо найти для доказательства гомотопности, — горизонтальный
путь на высоте `j` имеет тип `(pmap f ab) @ j = (pmap g ab) @ j`, или, что то же самое
по определению `pmap`, `f (ab j) = g (ab j)`. При этом, пути `p` и `q` это те самые
пути, которые необходимо использовать для доказательства `f a = g a` и
`f b = g b` соответственно, чтобы выполнялись граничные условия.

Кроме того, если `p` и `q` зафиксированы заранее, а `g` позволено выбрать какой угодно,
то в качестве образа `path ab` под действием `g` можно взять путь,
получающийся в результате заполнения короба, состоящего из `pmap f ab`, `p` и `q`.
Тогда отображения окажутся заведомо гомотопны, и доказательство этого будет
легко получить с помощью внутренности заполненного квадрата.
Эта идея будет использована в следующей главе.
