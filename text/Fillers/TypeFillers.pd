Заполнители в теории типов
---------------------------


В теории типов естественно в качестве $n$-мерных ячеек рассматривать
$n$-пути. Всегда ли можно заполнить короб, составленный из $n$-путей?
Оказывается, что всегда.

Начнем с простейшего случая, с заполнения $0$-короба.
По определению, $0$-короб состоит из одной точки:

~~~~{label=lst:box-0}
record box-0 (X : I -> Type) where
    constructor box-0
    xl : X left
 -- xr is missing
~~~~

Заполнить его — значит провести $1$-путь (в единственном
имеющемся направлении), соединяющий точку `xl` из `X left` с некоторой
точкой из `X right`:

~~~~{label=lst:fill-1-type}
fill-1 : (X : I -> Type)
      -> box-0 X
      -> (i1 : I) -> X i1
~~~~

Условие, что проведенный путь начинается в точке `xl`,
эквивалентно тому, что следующее определение проходит проверку типов:


~~~~{label=lst:fill-1-cond}
cond-1-l : (X : I -> Type)
        -> (xl : X left)
        -> fill-1 X (box-0 xl) left = xl
cond-1-l X xl = idp
~~~~

Заполнитель для $0$-короба — ни что иное, как `coe`:

~~~~{label=lst:fill-1-term}
fill-1 X b i1 = coe X left (b.xl) i1
~~~~

Каждый следующий заполнитель выражается через предыдущий. Например,
заполнитель для $1$-короба приведен в \inlref{листинге}{lst:fill-2}.


~~~~{label=lst:fill-2 float=ht caption="Заполнитель для $2$-короба"}
record box-1 (X : I -> I -> Type) where
    constructor box-1
    -- Vertices
    xll : X left  left
    xlr : X left  right
    xrl : X right left
    xrr : X right right
    -- Edges
    x_l : Path (\i1 -> X i1 left ) xll xrl
    x_r : Path (\i1 -> X i1 right) xlr xrr
    xl_ : Path (\i2 -> X left  i2) xll xlr
 -- xr_ is missing

fill-2 : (X : I -> I -> Type)
      -> box-1 X
      -> (i1 i2 : I) -> X i1 i2
fill-2 X b i1 i2 = fill-1 (\i1 -> Path (\i2 -> X i1 i2)
                                       (b.x_l @ i1) (b.x_r @ i1))
                          (box-1 (b.xl_))
                          i1 @ i2

cond-2-_l : (X : I -> I -> Type)
            (b : box-1 X)
         -> (i1 : I) -> fill-2 X b i1 left = (b.x_l) @ i1
cond-2-_l _ _ _ = idp

cond-2-_r : (X : I -> I -> Type)
            (b : box-1 X)
         -> (i1 : I) -> fill-2 X b i1 right = (b.x_r) @ i1
cond-2-_r _ _ _ = idp

cond-2-l_ : (X : I -> I -> Type)
            (b : box-1 X)
         -> (i2 : I) -> fill-2 X b left i2 = (b.xl_) @ i2
cond-2-l_ _ _ _ = idp
~~~~

В общем случае, имеются $(n+1)$ направление $i_1, i_2, …, i_{n+1}$ и,
соответственно, зависимый тип `X : I -> I -> … -> I -> Type`.
Идея состоит в том, чтобы перейти к пространству путей в
каком-либо выбранном направлении, тем самым уменьшив размерность
рассматриваемого пространства на единицу, и, по индукции,
взять заполнитель в полученном пространстве меньшей размерности.

При этом, есть два выделенных направления: то, в котором отсутствует
грань, и то, которое будет «схлопнуто» переходом к путям в этом направлении.
Чтобы термы имели простой вид, важно правильным
образом выбрать эти два направления. Удобнее всего оказывается
схлопывать последнее направление ($i_{n+1}$), поскольку в этом случае
первые $n$ направлений остаются нетронутыми, что хорошо для индукционного вызова;
соответственно, отсутствовать грань должна в направлении $i_1$.

Также, для удобства, необходимо зафиксировать некоторый способ перечисления
поверхностей короба. Например, можно перечислять их в порядке возрастания
размерности, затем в лексикографическом порядке неизменяющихся координат.
Иными словами, каждой поверхности куба можно сопоставить вектор из $\{?, 0, 1\}^{n+1}$
(где число вопросиков показывает размерность поверхности);
на этих векторах можно ввести порядок: сначала два вектора сравниваются по
числу вопросиков, затем — лексикографически ($? < 0 < 1$); поверхности следует
перечислять в соответствии с порядком на сопоставленных им векторах.
В примерах кода в названиях переменных вместо `?`, `0`, `1` использованы `_`, `l`, `r`.

Ещё один важный вопрос — в каком направлении проводить пути, являющиеся
гранями куба. К примеру, в трехмерном кубе грани представляют собой $2$-пути,
то есть пути в пространстве путей. Есть несколько вариантов описания такого типа:
можно сказать, что это путь вдоль $i_1$ между путями, идущими вдоль $i_2$,
а можно — что путь вдоль $i_2$ в пространстве путей вдоль $i_1$.
Записывая типы, мы перечисляем координаты в естественном порядке, тем самым
гарантируя, что всякий $k$-путь, который будет использован в индуктивном переходе,
уже сам по себе является $(k-1)$-путем в пространстве путей вдоль $i_{n+1}$, так что
его можно сразу же подставлять в рекурсивный вызов, никак не преобразовывая.

На \inlref{рисунке}{img:box-2} изображено графически определение 2-короба, а
\inlref{листинг}{lst:box-n} содержит схему определения типа `box-n` для произвольного $n$
на языке hoq.
<!-- TODO pic -->


~~~~{label=lst:box-n float=ht caption="Схема определения открытого $n$-короба"}
record box-n (X : I -> I -> … -> I -> Type) where
    constructor box-n
    -- Vertices
    xl…ll : X left  … left  left
    xl…lr : X left  … left  right
    xl…rl : X left  … right left
    xl…rr : X left  … right right
    …
    xr…ll : X right … left  left
    xr…lr : X right … left  right
    xr…rl : X right … right left
    xr…rr : X right … right right

    -- Edges
    x_l…ll : Path (\i1 -> X i1 left  … left  left ) xll…ll xrl…ll
    x_l…lr : Path (\i1 -> X i1 left  … left  right) xll…lr xrl…lr
    x_l…rl : Path (\i1 -> X i1 left  … right left ) xll…rl xrl…rl
    x_l…rr : Path (\i1 -> X i1 left  … right right) xll…rr xrl…rr
    …
    x_r…ll : Path (\i1 -> X i1 right … left  left ) xlr…ll xrr…ll
    x_r…lr : Path (\i1 -> X i1 right … left  right) xlr…lr xrr…lr
    x_r…rl : Path (\i1 -> X i1 right … right left ) xlr…rl xrr…rl
    x_r…rr : Path (\i1 -> X i1 right … right right) xlr…rr xrr…rr

    …

    xrr…l_ : Path (\in+1 -> X right right in+1) xrr…ll xrr…lr
    xrr…r_ : Path (\in+1 -> X right right in+1) xrr…rl xrr…rr

    -- 2-dimensional surfaces
    x__l…l : Path (\i1 -> Path (\i2 -> X i1 i2 left … left)
                               (x_l…ll @ i1) (x_r…ll @ i1))
                  xl_l…l xr_l…l

    …

    -- n-dimensional surfaces
    …
    xl_…_ : Path (\i2 -> Path (\i3 -> … Path (\in+1 -> X left i2 … in+1)…))
                 …
                 xll_…_ xlr_…_
 -- xr_…_ is missing
~~~~

Имея `box-n`, можно записать тип заполнителя в общем случае:

~~~~
fill-n : (X : I -> I -> … -> I -> Type)
      -> box-(n-1) X
      -> (i1 i2 … in : I) -> X i1 i2 … in
~~~~

Как было сказано выше, ключевая идея при построении терма, имеющего такой тип, —
перейти к пространству путей вдоль направления $i_{n+1}$ и,
поскольку его размерность на единицу меньше, по индукции найти заполнитель.
Выбранный способ перечисления вершин короба позволяет чисто механически
получить необходимый короб меньшей размерности: достаточно перечислять
поверхности исходного короба в том же порядке, заменяя последний символ
в имени поверхности на подчеркивание (тем самым, повышая её размерность, ведь
вершины в новом пространстве это $1$-пути, то есть ребра исходного куба).
В \inlref{листинге}{lst:fill-n} приведена схема построения заполнителя
произвольной размерности.

~~~{label=lst:fill-n float=ht caption="Схема заполнения открытого $n$-короба"}
fill-n : (X : I -> I -> … -> I -> Type)
      -> box-n X
      -> (i1 i2 … in+1 : I) -> X i1 i2 … in+1
fill-n X b i1 i2 … in+1 =
  fill-n-1 (\i1 … in -> Path (\in+1 -> X i1 … in in+1)
                             ((b.x_…_l) @ i1 @ … @ in)
                             ((b.x_…_r) @ i1 @ … @ in))
         (box-n-1 (b.xl…ll_) (b.xl…lr_) (b.xl…rl_) (b.xl…rr_)
                   …
                   (b.x_
                   (b.xl_…_))
         i1 … in @ in+1
~~~~
