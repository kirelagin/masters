Заполнители в теории типов
---------------------------


В теории типов естественно в качестве $n$-мерных ячеек рассматривать
$n$-пути. Всегда ли можно заполнить короб, составленный из $n$-путей?
Оказывается, что всегда.

Начнем с простейшего случая, с заполнения $0$-короба.
По определению, $0$-короб состоит из одной точки:

~~~~{label=lst:box-0}
record box-0 (X : I -> Type) where
    constructor box-0
    l : X left
 -- r is missing
~~~~

Заполнить его — значит провести $1$-путь (в единственном
имеющемся направлении), соединяющий точку `l` из `X left` с некоторой
точкой из `X right`:

~~~~{label=lst:fill-1-type}
fill-1 : (X : I -> Type)
      -> box-0 X
      -> (i1 : I) -> X i1
~~~~

Условие, что проведенный путь начинается в точке `l`,
эквивалентно тому, что следующее определение проходит проверку типов:


~~~~{label=lst:fill-1-cond}
cond-1-l : (X : I -> Type)
        -> (l : X left)
        -> fill-1 X (box-0 l) left = l
cond-1-l X l = idp
~~~~

Заполнитель для $0$-короба — ни что иное, как `coe`:

~~~~{label=lst:fill-1-term}
fill-1 X b i1 = coe X left (b.l) i1
~~~~

Каждый следующий заполнитель выражается через предыдущий. Например,
заполнитель для $1$-короба приведен в \inlref{листинге}{lst:fill-2}.


~~~~{label=lst:fill-2 float=ht caption="Заполнитель для $2$-короба"}
record box-1 (X : I -> I -> Type) where
    constructor box-1
    -- Vertices
    ll : X left  left
    lr : X left  right
    rl : X right left
    rr : X right right
    -- Edges
    _l : Path (\i1 -> X i1 left ) ll rl
    _r : Path (\i1 -> X i1 right) lr rr
    l_ : Path (\i2 -> X left  i2) ll lr
 -- r_ is missing

fill-2 : (X : I -> I -> Type)
      -> box-1 X
      -> (i1 i2 : I) -> X i1 i2
fill-2 X b i1 i2 = fill-1 (\i1 -> Path (\i2 -> X i1 i2)
                                       (b._l @ i1) (b._r @ i1))
                          (box-1 (b.l_))
                          i1 @ i2

cond-2-_l : (X : I -> I -> Type)
            (b : box-1 X)
         -> (i1 : I) -> fill-2 X b i1 left = (b._l) @ i1
cond-2-_l _ _ _ = idp

cond-2-_r : (X : I -> I -> Type)
            (b : box-1 X)
         -> (i1 : I) -> fill-2 X b i1 right = (b._r) @ i1
cond-2-_r _ _ _ = idp

cond-2-l_ : (X : I -> I -> Type)
            (b : box-1 X)
         -> (i2 : I) -> fill-2 X b left i2 = (b.l_) @ i2
cond-2-l_ _ _ _ = idp
~~~~

В общем случае, имеются $(n+1)$ направление $i_1, i_2, …, i_{n+1}$ и,
соответственно, зависимый тип `X : I -> I -> … -> I -> Type`.
Идея состоит в том, чтобы перейти к пространству путей в
каком-либо выбранном направлении, тем самым уменьшив размерность
рассматриваемого пространства на единицу, и, по индукции,
взять заполнитель в полученном пространстве меньшей размерности.

При этом, есть два выделенных направления: то, в котором отсутствует
грань, и то, которое будет «схлопнуто» переходом к путям в этом направлении.
Чтобы термы имели простой вид, важно правильным
образом выбрать эти два направления. Удобнее всего оказывается
схлопывать последнее направление ($i_{n+1}$), поскольку в этом случае
первые $n$ направлений остаются нетронутыми, что хорошо для индукционного вызова;
соответственно, отсутствовать грань должна в направлении $i_1$.

Также, для удобства, необходимо зафиксировать некоторый способ перечисления
поверхностей короба. Например, можно перечислять их в порядке возрастания
размерности, затем в лексикографическом порядке неизменяющихся координат.
Иными словами, каждой поверхности куба можно сопоставить вектор из $\{?, 0, 1\}^{n+1}$
(где число вопросиков показывает размерность поверхности);
на этих векторах можно ввести порядок: сначала два вектора сравниваются по
числу вопросиков, затем — лексикографически ($? < 0 < 1$); поверхности следует
перечислять в соответствии с порядком на сопоставленных им векторах.
В примерах кода в названиях переменных вместо `?`, `0`, `1` использованы `_`, `l`, `r`.

Ещё один важный вопрос — в каком направлении проводить пути, являющиеся
гранями куба. К примеру, в трехмерном кубе грани представляют собой $2$-пути,
то есть пути в пространстве путей. Есть несколько вариантов описания такого типа:
можно сказать, что это путь вдоль $i_1$ между путями, идущими вдоль $i_2$,
а можно — что путь вдоль $i_2$ в пространстве путей вдоль $i_1$.
Записывая типы, мы перечисляем координаты в естественном порядке, тем самым
гарантируя, что всякий $k$-путь, который будет использован в индуктивном переходе,
уже сам по себе является $(k-1)$-путем в пространстве путей вдоль $i_{n+1}$, так что
его можно сразу же подставлять в рекурсивный вызов, никак не преобразовывая.

На \inlref{рисунке}{img:box-2} изображено графически определение 2-короба, а
\inlref{листинг}{lst:box-n} содержит схему определения типа `box-n` для произвольного $n$
на языке hoq.
<!-- TODO pic -->


~~~~{label=lst:box-n float=ht caption="Схема определения открытого $n$-короба"}
record box-n (X : I -> I -> … -> I -> Type) where
    constructor box-n
    -- Vertices
    l…ll : X left  … left  left
    l…lr : X left  … left  right
    l…rl : X left  … right left
    l…rr : X left  … right right
    …
    r…ll : X right … left  left
    r…lr : X right … left  right
    r…rl : X right … right left
    r…rr : X right … right right

    -- Edges
    _l…ll : Path (\i1 -> X i1 left  … left  left ) ll…ll rl…ll
    _l…lr : Path (\i1 -> X i1 left  … left  right) ll…lr rl…lr
    _l…rl : Path (\i1 -> X i1 left  … right left ) ll…rl rl…rl
    _l…rr : Path (\i1 -> X i1 left  … right right) ll…rr rl…rr
    …
    _r…ll : Path (\i1 -> X i1 right … left  left ) lr…ll rr…ll
    _r…lr : Path (\i1 -> X i1 right … left  right) lr…lr rr…lr
    _r…rl : Path (\i1 -> X i1 right … right left ) lr…rl rr…rl
    _r…rr : Path (\i1 -> X i1 right … right right) lr…rr rr…rr

    …

    rr…l_ : Path (\in+1 -> X right right in+1) rr…ll rr…lr
    rr…r_ : Path (\in+1 -> X right right in+1) rr…rl rr…rr

    -- 2-dimensional surfaces
    __l…l : Path (\i1 -> Path (\i2 -> X i1 i2 left … left)
                               (_l…ll @ i1) (_r…ll @ i1))
                  l_l…l r_l…l

    …

    -- n-dimensional surfaces
    …
    l_…_ : Path (\i2 -> Path (\i3 -> … Path (\in+1 -> X left i2 … in+1)…))
                 …
                 ll_…_ lr_…_
 -- r_…_ is missing
~~~~

Имея `box-n`, можно записать тип заполнителя в общем случае:

~~~~
fill-n : (X : I -> I -> … -> I -> Type)
      -> box-(n-1) X
      -> (i1 i2 … in : I) -> X i1 i2 … in
~~~~

Как было сказано выше, ключевая идея при построении терма, имеющего такой тип, —
перейти к пространству путей вдоль направления $i_{n+1}$ и,
поскольку его размерность на единицу меньше, по индукции найти заполнитель.
Выбранный способ перечисления вершин короба позволяет чисто механически
получить необходимый короб меньшей размерности: достаточно перечислять
поверхности исходного короба в том же порядке, заменяя последний символ
в имени поверхности на подчеркивание (тем самым, повышая её размерность, ведь
вершины в новом пространстве это $1$-пути, то есть ребра исходного куба).
В \inlref{листинге}{lst:fill-n} приведена схема построения заполнителя
произвольной размерности.

~~~{label=lst:fill-n float=ht caption="Схема заполнения открытого $n$-короба"}
fill-n : (X : I -> I -> … -> I -> Type)
      -> box-n X
      -> (i1 i2 … in+1 : I) -> X i1 i2 … in+1
fill-n X b i1 i2 … in+1 =
  fill-n-1 (\i1 … in -> Path (\in+1 -> X i1 … in in+1)
                             ((b._…_l) @ i1 @ … @ in)
                             ((b._…_r) @ i1 @ … @ in))
         (box-n-1 (b.l…ll_) (b.l…lr_) (b.l…rl_) (b.l…rr_)
                   …
                   (b._
                   (b.l_…_))
         i1 … in @ in+1
~~~~
