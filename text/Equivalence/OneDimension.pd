Заполнители в доказательствах эквивалентности
----------------------------------------------


Начнем с простейшего случая, а именно, проверим, что отрезок
гомотопически эквивалентен трем отрезкам, склеенным последовательно.
Определим эти типы следующим образом:

~~~~
data I1 = u | v | uv I
  with
    uv left  = u
    uv right = v

data I3 = a | b | c | d | bc I | ba I | cd I
  with
    bc left  = b
    bc right = c
    ba left  = b
    ba right = a
    cd left  = c
    cd right = d
~~~~

Для этого нам потребуется построить отображение `f : I3 -> I1`, отображение
`g : I1 -> I3`, а также доказать, что композиция этих двух отображений
в любом порядке гомотопна тождественному отображению.

Само по себе это утверждение очевидно, и может быть доказано очень
легко, ведь оба типа стягиваемы. Поэтому мы предъявим к эквивалентности
дополнительное требование: необходимо, чтобы оба отображения переводили
границу в границу, то есть:

~~~~
f a = u
f d = v

g u = a
g v = d
~~~~

Такое требование исключает возможность использования тождественных отображений
для построения эквивалентности, а также позволит в будущем применить
тот же самый подход в более интересных ситуациях.
Например, если мы дополнительно отождествим в обоих типах граничные точки,
то получим «окружности», в одном случае, состоящую из одного отрезка, а в
другом — из трех. Но если наше доказательство переводило граничные точки
в граничные, то оно сработает и теперь.

Приступим к построению отображений. Отображение `f : I3 -> I1` построить
несложно. Отобразим центральный отрезок в исходном типе в единственный
отрезок в целевом, а остальные два отразим в вырожденные отрезки:

~~~~
f : I3 -> I1
f a      = u
f (ba _) = u
f b      = u
f (bc i) = uv i
f c      = v
f (cd _) = v
f d      = v
~~~~

Каким должно быть отображение в обратную сторону, менее очевидно.
Дело в том, что отрезок в `I1` необходимо отобразить в какой-то
отрезов в `I3`, но ни один из имеющихся там отрезков не подходит
из-за требования про отображение границы. Единственный выход —
отображать в «конкатенацию» всех трех отрезков, и это можно сделать
с помощью заполнителя:

~~~~
g : I1 -> I3
g u      = a
g (uv i) = fill-2 (\_ _ -> I3)
                  (box-1 b c a d (path ba) (path cd) (path bc))
                  right i
g v      = d
~~~~

Следующее, что надо сделать, это доказать, что композиции гомотопны тождественной
функции. Как обсуждалось ранее, в случае, когда одно из отображений
определено с помощью заполнения, в поиске необходимых путей помогает сам заполнитель.
Мы должны построить терм, имеющий следующий тип:

~~~~
g-then-f : (x : I1) -> x = f (g x)
~~~~

Поскольку обе функции определены в терминах отображения отрезков в отрезки,
проще думать о том, что там нужно найти путь между путями `path uv` и
`pmap f (pmap g (path uv))`. Как мы помним, функция `g`, по определению,
отображает отрезок в конкатенацию трех отрезков, так что этот тип вычислительно
равен следующему: `path uv = pmap f (concat3 (inv (path ba)) (path bc) (path cd))`,
а если раскрыть по определению `concat3` правую часть равенства, то получим
`path uv = pmap f (fill-2 … (path ba) (path cd) (path bc))`.

Теперь можно было бы доказать, что применение функции коммутирует с
взятием заполнителя, и, поскольку `pmap f (path ba) = pmap f (path cd) = idp`
по определению `f`, получить в правой части `pmap f (path bc)`,
что равно `path uv` по определению `f`, но мы поступим иначе.

Вместо этого, мы напрямую построим искомые пути `uv j = f (g (uv j))`.
На \inlref{рисунке}{img:g-then-f}<!-- TODO pic --> изображен заполнитель,
использованный в определении `g`. Подействуем на все изображенные пути
отображением `f` и заметим, что горизонтальные пути, проходящие через
заполненный квадрат, это как раз то, что мы ищем. Остается только
выписать доказательство:

~~~~
g-then-f : (x : I1) -> x = f (g x)
g-then-f u      = idp
g-then-f v      = idp
g-then-f (uv j) =
  path (\i ->
    f (fill-2 (\_ _ -> I3)
              (box-1 b c a d (path ba) (path cd) (path bc)) i j))
~~~~

Обратимся теперь к доказательству в другую сторону.
Ищем терм типа:

~~~~
f-then-g : (x : I3) -> x = g (f x)
~~~~

Интересный случай — когда `x` это `bc j`, а все остальные получатся
из граничных условий и элементарных соображений. В этом случае
требуется доказать, по определению `f`, что
`bc j = g (uv j)`, но мы только что видели именно такой путь!
Только в этот раз даже не надо действовать отображением `f`.

В точках `b` и `c`, как видно из \inlref{рисунка}{img:g-then-f},
возвращать необходимо пути `path ba` и `path cd`. В точке
`ba j` нужен путь `(path ba) @ j = a`, причем при `j = left`
он должен обращаться в `path ba`, а при `j = right` —
в тождественный. Именно для этого нужна функция `ptrim'`.
В итоге получаем:

~~~~
f-then-g : (x : I3) -> x = g (f x)
f-then-g a      = idp
f-then-g (ba j) = ptrim' (path ba) j
f-then-g b      = path ba
f-then-g (bc j) =
  path (\i ->
      (fill-2 (\_ _ -> I3)
              (box-1 b c a d (path ba) (path cd) (path bc)) i j))
f-then-g c      = path cd
f-then-g (cd j) = ptrim' (path cd) j
f-then-g d      = idp
~~~~

Таким образом, мы доказали, что **типы `I1` и `I3` гомотопически эквивалентны**.
