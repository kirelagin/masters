Склеивание поверхностей
------------------------


У операции заполнения есть простой и понятный смысл:
она получает на вход несколько _совместимых_ (правильным образом
образующих грани одного куба) $(n-1)$-путей и выдает новый $(n-1)$-путь,
получающихся из исходных склеиванием.

К примеру, при $n=1$ изначально даны три ребра квадрата,
которые можно рассматривать как три пути, причем такие, что начальная точка
второго пути совпадает с начальной точкой первого, а конечная
точка второго — с начальной точкой третьего. В этом случае,
недостающая грань — конкатенация трех путей (первый при этом необходимо развернуть).
<!-- TODO pic -->
В \inlref{листинге}{lst:fill-2-face} приведена функция, использующая
заполнитель для того, чтобы восстановить недостающее ребро квадрата,
затем она использована в \inlref{листинге}{lst:concat3}
для определения конкатенации трех путей.

~~~~{label=lst:fill-2-face float=ht caption="Восстановление грани 2-куба"}
fill-2-face : (X : I -> I -> Type)
           -> (b : open-box-1 X)
           -> Path (\i2 -> X right i2) (b.xrl) (b.xrr)
fill-2-face X b = path (\i2 -> fill-2 X b right i2)
~~~~

~~~~{label=lst:concat3 float=ht caption="Конкатенация трех путей"}
concat3 : {A : Type}
       -> {a b c d : A}
       -> (p1 : a = b) (p2 : b = c) (p3 : c = d)
       -> a = d
concat3 A a b c d p1 p2 p3 =
  fill-2-face (\_ _ -> A) (open-box-1 b c a d (inv p1) p3 p2)
~~~~

С помощью этого метода можно доказывать эквивалентность типов,
состоящих из разного числа интервалов (и высших поверхностей).
К примеру, в \inlref{листинге}{lst:I3-equiv} приведено отображение
из типа `I3` в тип `I` (три склеенных последовательно интервала),
а также обратное к нему.

~~~~{label=lst:I3-equiv float=ht caption="Эквивалентность \lstinline{I} и \lstinline{I3}"}
data I3 = first I | second I | third I
  with
    first right = second left
    second right = third left

f : I3 -> I
f (first _)  = left
f (third _)  = right
f (second i) = i

g : I -> I3
g i = concat3 (path first) (path second) (path third) @ i
~~~~

Прямое отображение не вызывает трудностей, поскольку его область состоит
из большего числа «ячеек», потому некоторые из них можно схлопнуть
в точки. Как построить обратное отображение, однако, не столь очевидно,
ведь в его области есть только один интервал, а в кообласти — три, и
их все надо покрыть. С помощью же заполнения это сделать становится просто —
достаточно рассмотреть три пути, соответствующие трем интервалам, объединить
их в один путь, а затем путь в `I` отобразить в новый путь в `I3`.
